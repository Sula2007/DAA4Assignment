// ===================================================================
// FILE: src/main/java/graph/data/GraphDataGenerator.java
// Generates test datasets for the algorithms
// ===================================================================
package graph.data;

import graph.common.Graph;
import java.io.*;
import java.util.*;

/**
 * Generates various graph datasets for testing algorithms.
 * Creates small, medium, and large graphs with different structures.
 */
public class GraphDataGenerator {
    private final Random random;
    
    public GraphDataGenerator(long seed) {
        this.random = new Random(seed);
    }
    
    /**
     * Generate a graph with specified parameters.
     * @param n Number of vertices
     * @param density Edge density (0.0 to 1.0)
     * @param cyclic Whether to include cycles
     * @param minWeight Minimum edge weight
     * @param maxWeight Maximum edge weight
     */
    public Graph generate(int n, double density, boolean cyclic, 
                         int minWeight, int maxWeight) {
        Graph graph = new Graph(n);
        
        // Set task names
        for (int i = 0; i < n; i++) {
            graph.setTaskName(i, "Task-" + i);
        }
        
        if (cyclic) {
            generateCyclic(graph, n, density, minWeight, maxWeight);
        } else {
            generateDAG(graph, n, density, minWeight, maxWeight);
        }
        
        return graph;
    }
    
    private void generateDAG(Graph graph, int n, double density, 
                            int minWeight, int maxWeight) {
        int maxEdges = n * (n - 1) / 2;
        int targetEdges = (int) (maxEdges * density);
        
        Set<String> addedEdges = new HashSet<>();
        int edgesAdded = 0;
        
        // Add edges only from lower to higher indices (ensures DAG)
        while (edgesAdded < targetEdges) {
            int from = random.nextInt(n - 1);
            int to = from + 1 + random.nextInt(n - from - 1);
            
            String edgeKey = from + "->" + to;
            if (!addedEdges.contains(edgeKey)) {
                int weight = minWeight + random.nextInt(maxWeight - minWeight + 1);
                graph.addEdge(from, to, weight);
                addedEdges.add(edgeKey);
                edgesAdded++;
            }
        }
    }
    
    private void generateCyclic(Graph graph, int n, double density,
                               int minWeight, int maxWeight) {
        int maxEdges = n * (n - 1);
        int targetEdges = (int) (maxEdges * density);
        
        // First create some SCCs
        int numSCCs = Math.max(2, n / 4);
        List<List<Integer>> sccs = new ArrayList<>();
        
        // Distribute vertices into SCCs
        List<Integer> vertices = new ArrayList<>();
        for (int i = 0; i < n; i++) vertices.add(i);
        Collections.shuffle(vertices, random);
        
        for (int i = 0; i < numSCCs; i++) {
            sccs.add(new ArrayList<>());
        }
        
        for (int i = 0; i < n; i++) {
            sccs.get(i % numSCCs).add(vertices.get(i));
        }
        
        // Create cycles within each SCC
        for (List<Integer> scc : sccs) {
            if (scc.size() > 1) {
                for (int i = 0; i < scc.size(); i++) {
                    int from = scc.get(i);
                    int to = scc.get((i + 1) % scc.size());
                    int weight = minWeight + random.nextInt(maxWeight - minWeight + 1);
                    graph.addEdge(from, to, weight);
                }
            }
        }
        
        // Add random edges between and within SCCs
        Set<String> addedEdges = new HashSet<>();
        int edgesAdded = scc.stream().mapToInt(List::size).sum();
        
        while (edgesAdded < targetEdges) {
            int from = random.nextInt(n);
            int to = random.nextInt(n);
            
            if (from != to) {
                String edgeKey = from + "->" + to;
                if (!addedEdges.contains(edgeKey)) {
                    int weight = minWeight + random.nextInt(maxWeight - minWeight + 1);
                    graph.addEdge(from, to, weight);
                    addedEdges.add(edgeKey);
                    edgesAdded++;
                }
            }
        }
    }
    
    /**
     * Save graph to JSON file.
     */
    public void saveToJSON(Graph graph, String filename) throws IOException {
        try (PrintWriter writer = new PrintWriter(new FileWriter(filename))) {
            writer.println("{");
            writer.println("  \"vertices\": " + graph.getVertices() + ",");
            writer.println("  \"tasks\": [");
            
            for (int i = 0; i < graph.getVertices(); i++) {
                writer.print("    {\"id\": " + i + ", \"name\": \"" + 
                           graph.getTaskName(i) + "\"}");
                if (i < graph.getVertices() - 1) writer.print(",");
                writer.println();
            }
            
            writer.println("  ],");
            writer.println("  \"edges\": [");
            
            boolean first = true;
            for (int i = 0; i < graph.getVertices(); i++) {
                for (Graph.Edge edge : graph.getAdjacent(i)) {
                    if (!first) writer.println(",");
                    writer.print("    {\"from\": " + i + ", \"to\": " + 
                               edge.to + ", \"weight\": " + edge.weight + "}");
                    first = false;
                }
            }
            
            writer.println();
            writer.println("  ]");
            writer.println("}");
        }
    }
    
    public static void main(String[] args) throws IOException {
        GraphDataGenerator generator = new GraphDataGenerator(42);
        
        // Create data directory
        new File("data").mkdirs();
        
        System.out.println("Generating datasets...\n");
        
        // Small graphs (6-10 vertices)
        System.out.println("=== Small Graphs ===");
        generateAndSave(generator, "data/small_dag_1.json", 6, 0.3, false, 1, 10);
        generateAndSave(generator, "data/small_cyclic_1.json", 8, 0.4, true, 1, 10);
        generateAndSave(generator, "data/small_mixed_1.json", 10, 0.35, true, 1, 15);
        
        // Medium graphs (10-20 vertices)
        System.out.println("\n=== Medium Graphs ===");
        generateAndSave(generator, "data/medium_dag_1.json", 12, 0.25, false, 1, 20);
        generateAndSave(generator, "data/medium_cyclic_1.json", 15, 0.3, true, 1, 20);
        generateAndSave(generator, "data/medium_sparse_1.json", 18, 0.15, true, 1, 25);
        
        // Large graphs (20-50 vertices)
        System.out.println("\n=== Large Graphs ===");
        generateAndSave(generator, "data/large_dag_1.json", 25, 0.2, false, 1, 30);
        generateAndSave(generator, "data/large_cyclic_1.json", 35, 0.15, true, 1, 30);
        generateAndSave(generator, "data/large_dense_1.json", 45, 0.25, true, 1, 40);
        
        System.out.println("\nâœ“ All datasets generated successfully!");
    }
    
    private static void generateAndSave(GraphDataGenerator gen, String filename,
                                       int n, double density, boolean cyclic,
                                       int minW, int maxW) throws IOException {
        Graph g = gen.generate(n, density, cyclic, minW, maxW);
        gen.saveToJSON(g, filename);
        System.out.printf("Generated %s: %d vertices, %d edges, %s%n",
            filename, n, g.getEdgeCount(), cyclic ? "cyclic" : "DAG");
    }
}

// ===================================================================
// FILE: src/test/java/graph/scc/TarjanSCCTest.java
// JUnit tests for Tarjan's SCC algorithm
// ===================================================================
package graph.scc;

import graph.common.Graph;
import graph.common.MetricsImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.util.List;

public class TarjanSCCTest {
    
    @Test
    public void testSimpleCycle() {
        // Graph: 0 -> 1 -> 2 -> 0
        Graph graph = new Graph(3);
        graph.addEdge(0, 1, 1);
        graph.addEdge(1, 2, 1);
        graph.addEdge(2, 0, 1);
        
        TarjanSCC tarjan = new TarjanSCC(graph, new MetricsImpl());
        List<List<Integer>> sccs = tarjan.findSCCs();
        
        assertEquals(1, sccs.size(), "Should have 1 SCC");
        assertEquals(3, sccs.get(0).size(), "SCC should contain 3 vertices");
    }
    
    @Test
    public void testMultipleSCCs() {
        // Two separate cycles: 0->1->0 and 2->3->2
        Graph graph = new Graph(4);
        graph.addEdge(0, 1, 1);
        graph.addEdge(1, 0, 1);
        graph.addEdge(2, 3, 1);
        graph.addEdge(3, 2, 1);
        
        TarjanSCC tarjan = new TarjanSCC(graph, new MetricsImpl());
        List<List<Integer>> sccs = tarjan.findSCCs();
        
        assertEquals(2, sccs.size(), "Should have 2 SCCs");
    }
    
    @Test
    public void testDAG() {
        // Simple DAG: 0 -> 1 -> 2
        Graph graph = new Graph(3);
        graph.addEdge(0, 1, 1);
        graph.addEdge(1, 2, 1);
        
        TarjanSCC tarjan = new TarjanSCC(graph, new MetricsImpl());
        List<List<Integer>> sccs = tarjan.findSCCs();
        
        assertEquals(3, sccs.size(), "DAG should have n SCCs");
        for (List<Integer> scc : sccs) {
            assertEquals(1, scc.size(), "Each SCC should have 1 vertex");
        }
    }
    
    @Test
    public void testCondensationGraph() {
        // Graph with 2 SCCs connected
        Graph graph = new Graph(5);
        graph.addEdge(0, 1, 1);
        graph.addEdge(1, 0, 1);  // SCC1: {0, 1}
        graph.addEdge(2, 3, 1);
        graph.addEdge(3, 2, 1);  // SCC2: {2, 3}
        graph.addEdge(1, 2, 1);  // Edge between SCCs
        graph.addEdge(3, 4, 1);  // SCC3: {4}
        
        TarjanSCC tarjan = new TarjanSCC(graph, new MetricsImpl());
        List<List<Integer>> sccs = tarjan.findSCCs();
        Graph condensation = tarjan.buildCondensationGraph(sccs);
        
        assertEquals(3, condensation.getVertices(), "Should have 3 components");
        assertTrue(condensation.getEdgeCount() >= 2, "Should have edges between components");
    }
    
    @Test
    public void testSingleVertex() {
        Graph graph = new Graph(1);
        
        TarjanSCC tarjan = new TarjanSCC(graph, new MetricsImpl());
        List<List<Integer>> sccs = tarjan.findSCCs();
        
        assertEquals(1, sccs.size());
        assertEquals(1, sccs.get(0).size());
    }
    
    @Test
    public void testDisconnectedGraph() {
        // Two disconnected vertices
        Graph graph = new Graph(2);
        
        TarjanSCC tarjan = new TarjanSCC(graph, new MetricsImpl());
        List<List<Integer>> sccs = tarjan.findSCCs();
        
        assertEquals(2, sccs.size(), "Disconnected vertices are separate SCCs");
    }
}

// ===================================================================
// FILE: src/test/java/graph/topo/TopologicalSortTest.java
// JUnit tests for topological sorting
// ===================================================================
package graph.topo;

import graph.common.Graph;
import graph.common.MetricsImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.util.List;
import java.util.HashSet;
import java.util.Set;

public class TopologicalSortTest {
    
    @Test
    public void testSimpleDAG() {
        // 0 -> 1 -> 2
        Graph graph = new Graph(3);
        graph.addEdge(0, 1, 1);
        graph.addEdge(1, 2, 1);
        
        TopologicalSort topo = new TopologicalSort(graph, new MetricsImpl());
        List<Integer> order = topo.kahnSort();
        
        assertEquals(3, order.size());
        assertTrue(order.indexOf(0) < order.indexOf(1));
        assertTrue(order.indexOf(1) < order.indexOf(2));
    }
    
    @Test
    public void testMultiplePaths() {
        // Diamond shape: 0 -> {1, 2} -> 3
        Graph graph = new Graph(4);
        graph.addEdge(0, 1, 1);
        graph.addEdge(0, 2, 1);
        graph.addEdge(1, 3, 1);
        graph.addEdge(2, 3, 1);
        
        TopologicalSort topo = new TopologicalSort(graph, new MetricsImpl());
        List<Integer> order = topo.kahnSort();
        
        assertEquals(4, order.size());
        assertTrue(order.indexOf(0) < order.indexOf(1));
        assertTrue(order.indexOf(0) < order.indexOf(2));
        assertTrue(order.indexOf(1) < order.indexOf(3));
        assertTrue(order.indexOf(2) < order.indexOf(3));
    }
    
    @Test
    public void testCycleDetection() {
        // Graph with cycle: 0 -> 1 -> 2 -> 0
        Graph graph = new Graph(3);
        graph.addEdge(0, 1, 1);
        graph.addEdge(1, 2, 1);
        graph.addEdge(2, 0, 1);
        
        TopologicalSort topo = new TopologicalSort(graph, new MetricsImpl());
        
        assertThrows(IllegalStateException.class, () -> topo.kahnSort());
    }
    
    @Test
    public void testDFSSort() {
        // 0 -> 1 -> 2
        Graph graph = new Graph(3);
        graph.addEdge(0, 1, 1);
        graph.addEdge(1, 2, 1);
        
        TopologicalSort topo = new TopologicalSort(graph, new MetricsImpl());
        List<Integer> order = topo.dfsSort();
        
        assertEquals(3, order.size());
        assertTrue(order.indexOf(0) < order.indexOf(1));
        assertTrue(order.indexOf(1) < order.indexOf(2));
    }
    
    @Test
    public void testSingleVertex() {
        Graph graph = new Graph(1);
        
        TopologicalSort topo = new TopologicalSort(graph, new MetricsImpl());
        List<Integer> order = topo.kahnSort();
        
        assertEquals(1, order.size());
        assertEquals(0, order.get(0));
    }
    
    @Test
    public void testComplexDAG() {
        // More complex DAG
        Graph graph = new Graph(6);
        graph.addEdge(5, 2, 1);
        graph.addEdge(5, 0, 1);
        graph.addEdge(4, 0, 1);
        graph.addEdge(4, 1, 1);
        graph.addEdge(2, 3, 1);
        graph.addEdge(3, 1, 1);
        
        TopologicalSort topo = new TopologicalSort(graph, new MetricsImpl());
        List<Integer> order = topo.kahnSort();
        
        assertEquals(6, order.size());
        
        // Verify all edges go forward in the order
        Set<Integer> seen = new HashSet<>();
        for (int v : order) {
            seen.add(v);
            for (Graph.Edge edge : graph.getAdjacent(v)) {
                assertFalse(seen.contains(edge.to), 
                    "Edge to already-seen vertex: " + v + " -> " + edge.to);
            }
        }
    }
}

// ===================================================================
// FILE: src/test/java/graph/dagsp/DAGShortestPathTest.java
// JUnit tests for DAG shortest/longest paths
// ===================================================================
package graph.dagsp;

import graph.common.Graph;
import graph.common.MetricsImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.util.List;

public class DAGShortestPathTest {
    
    @Test
    public void testShortestPathSimple() {
        // 0 --5--> 1 --3--> 2
        Graph graph = new Graph(3);
        graph.addEdge(0, 1, 5);
        graph.addEdge(1, 2, 3);
        
        DAGShortestPath dagSP = new DAGShortestPath(graph, new MetricsImpl());
        DAGShortestPath.PathResult result = dagSP.shortestPaths(0);
        
        assertEquals(0, result.distances[0]);
        assertEquals(5, result.distances[1]);
        assertEquals(8, result.distances[2]);
        
        List<Integer> path = result.reconstructPath(2);
        assertEquals(3, path.size());
        assertEquals(0, path.get(0));
        assertEquals(1, path.get(1));
        assertEquals(2, path.get(2));
    }
    
    @Test
    public void testShortestPathMultiplePaths() {
        // Diamond: 0 -> {1(5), 2(2)} -> 3
        Graph graph = new Graph(4);
        graph.addEdge(0, 1, 5);
        graph.addEdge(0, 2, 2);
        graph.addEdge(1, 3, 1);
        graph.addEdge(2, 3, 4);
        
        DAGShortestPath dagSP = new DAGShortestPath(graph, new MetricsImpl());
        DAGShortestPath.PathResult result = dagSP.shortestPaths(0);
        
        assertEquals(6, result.distances[3], "Shortest path: 0->1->3");
    }
    
    @Test
    public void testLongestPathSimple() {
        // 0 --5--> 1 --3--> 2
        Graph graph = new Graph(3);
        graph.addEdge(0, 1, 5);
        graph.addEdge(1, 2, 3);
        
        DAGShortestPath dagSP = new DAGShortestPath(graph, new MetricsImpl());
        DAGShortestPath.PathResult result = dagSP.longestPaths(0);
        
        assertEquals(0, result.distances[0]);
        assertEquals(5, result.distances[1]);
        assertEquals(8, result.distances[2]);
    }
    
    @Test
    public void testLongestPathMultiplePaths() {
        // Diamond: 0 -> {1(5), 2(2)} -> 3
        Graph graph = new Graph(4);
        graph.addEdge(0, 1, 5);
        graph.addEdge(0, 2, 2);
        graph.addEdge(1, 3, 1);
        graph.addEdge(2, 3, 4);
        
        DAGShortestPath dagSP = new DAGShortestPath(graph, new MetricsImpl());
        DAGShortestPath.PathResult result = dagSP.longestPaths(0);
        
        assertEquals(6, result.distances[3], "Both paths have same length");
    }
    
    @Test
    public void testCriticalPath() {
        // Project scheduling graph
        Graph graph = new Graph(6);
        graph.addEdge(0, 1, 5);
        graph.addEdge(0, 2, 3);
        graph.addEdge(1, 3, 6);
        graph.addEdge(2, 3, 4);
        graph.addEdge(2, 4, 2);
        graph.addEdge(3, 5, 2);
        graph.addEdge(4, 5, 1);
        
        DAGShortestPath dagSP = new DAGShortestPath(graph, new MetricsImpl());
        DAGShortestPath.PathResult result = dagSP.findCriticalPath();
        
        assertNotNull(result);
        assertTrue(result.distances[5] >= 13, "Critical path should be longest");
    }
    
    @Test
    public void testUnreachableVertex() {
        // 0 -> 1, 2 (disconnected)
        Graph graph = new Graph(3);
        graph.addEdge(0, 1, 5);
        
        DAGShortestPath dagSP = new DAGShortestPath(graph, new MetricsImpl());
        DAGShortestPath.PathResult result = dagSP.shortestPaths(0);
        
        assertEquals(Integer.MAX_VALUE, result.distances[2]);
        assertTrue(result.reconstructPath(2).isEmpty());
    }
    
    @Test
    public void testPathReconstruction() {
        // 0 -> 1 -> 2 -> 3
        Graph graph = new Graph(4);
        graph.addEdge(0, 1, 2);
        graph.addEdge(1, 2, 3);
        graph.addEdge(2, 3, 1);
        
        DAGShortestPath dagSP = new DAGShortestPath(graph, new MetricsImpl());
        DAGShortestPath.PathResult result = dagSP.shortestPaths(0);
        
        List<Integer> path = result.reconstructPath(3);
        assertEquals(4, path.size());
        assertEquals(0, path.get(0));
        assertEquals(1, path.get(1));
        assertEquals(2, path.get(2));
        assertEquals(3, path.get(3));
    }
}
